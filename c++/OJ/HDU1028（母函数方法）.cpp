#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <iostream>
using namespace std;
typedef long long ll;

//母函数
//G(x) = (1 + x^1 + x^2..+x^n)(1 + x^2 + x^4 + x^6 + ...)(1 + x^3 + x^6 +..)(..)(1 + x^n)
//第一个表达式(1 + x^1 + x^2..+x^n)中 x的指数代表【解中'1'的出现次数】 比如x^2 = x^(1 * 2) 这是'1'出现了两次 x^3 = x^(1 * 3) '1'出现3次
//相似的 第二个表达式(1 + x^2 + x^4 + x^6 + ...) x^4 = x^(2 * 2) '2'出现两次 x^6 = x^(2 * 3) '1'出现3次
//...以此类推 【* 1（0次项） 是代表该数字出现次数为0】

//乘法原理的应用：每一个表达式 表示的都是 某个变量的所有取值【比如第一个表达式 表示'1'可以取的值(即n拆分后'1'出现的次数)可以为 {0，1，2...n}】
//每个变量的所有取值的乘积 就是问题的所有的解（在本问题中表现为‘和’）
//例子：4 = 2 + 1 + 1就是  x^(1 * 2)【'1'出现2次】
//			* x^(2 * 1)【'2'出现1次】
//			* x^(3 * 0)【'3'出现0次】
//			* x^(4 * 0)【..】
//			的结果
//上述4个分式乘起来等于 1 * (x^4) 代表 4的一个拆分解
//所以 G(x)展开后 其中x^n的系数就是 n的拆分解个数


int main(){
	int C1[123], C2[123], n;

	while(cin>>n){
		for(int i = 0; i <= n; i++){//初始化 第一个表达式 目前所有指数项的系数都为1
			C1[i] = 1;//C1为前i-1个表达式累乘后各个指数项的系数
			C2[i] = 0;
		}
		for(int i = 2; i <= n; i++){//第2至第n个表达式
			for(int j = 0; j <= n; j++)
				//k为第i个表达式每个项的指数 第一项为1【即x^(i * 0)】（指数k=0），第二项为x^(i * 1)（指数为k=i）， 第三项为x^(i * 2)... 所以k的步长为i
				for(int k = 0; j + k <= n; k += i)
					//(ax^j)*(x^k) = ax^(j+k) -> C2[j+k] += a  【第i个表达式每一项的系数都为1； a为C1[j]的值（x^j的系数）； C2为乘上第i个表达式后各指数项的系数】
					C2[j + k] += C1[j];
			for(int j = 0; j <= n; j++){//刷新当前累乘结果各指数项的系数
				C1[j] = C2[j];
				C2[j] = 0;
			}
		}
		cout<<C1[n]<<endl;
	}
	return 0;
}